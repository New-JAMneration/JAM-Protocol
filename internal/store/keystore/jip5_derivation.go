package keystore

import (
	"crypto/ed25519"
	"encoding/binary"
	"errors"
	"fmt"

	"github.com/New-JAMneration/JAM-Protocol/internal/types"
	"github.com/New-JAMneration/JAM-Protocol/internal/utilities/hash"
	vrf "github.com/New-JAMneration/JAM-Protocol/pkg/Rust-VRF/vrf-func-ffi/src"
)

// DeriveValidatorKeys derives Ed25519 and Bandersnatch secret key seeds from a 32-byte seed
// according to JIP-5 specification.
//
// Given a 32-byte seed, the derivation is:
//   - ed25519_secret_seed = blake2b("jam_val_key_ed25519" ++ seed)
//   - bandersnatch_secret_seed = blake2b("jam_val_key_bandersnatch" ++ seed)
//
// Returns:
//   - ed25519Secret: 32-byte Ed25519 secret key seed
//   - bandersnatchSecret: 32-byte Bandersnatch secret key seed
//   - ed25519Public: 32-byte Ed25519 public key
//   - bandersnatchPublic: 32-byte Bandersnatch public key
func DeriveValidatorKeys(seed []byte) (
	ed25519Secret []byte,
	bandersnatchSecret []byte,
	ed25519Public types.Ed25519Public,
	bandersnatchPublic types.BandersnatchPublic,
	err error,
) {
	if len(seed) != 32 {
		return nil, nil, types.Ed25519Public{}, types.BandersnatchPublic{},
			errors.New("seed must be exactly 32 bytes")
	}

	// Derive Ed25519 secret seed
	ed25519Prefix := []byte("jam_val_key_ed25519")
	ed25519Input := append(ed25519Prefix, seed...)
	ed25519Hash := hash.Blake2bHash(ed25519Input)
	ed25519Secret = ed25519Hash[:]

	// Derive Ed25519 key pair from seed
	ed25519Priv := ed25519.NewKeyFromSeed(ed25519Secret)
	ed25519Pub := ed25519Priv.Public().(ed25519.PublicKey)
	if len(ed25519Pub) != 32 {
		return nil, nil, types.Ed25519Public{}, types.BandersnatchPublic{},
			errors.New("invalid Ed25519 public key size")
	}
	copy(ed25519Public[:], ed25519Pub)

	// Derive Bandersnatch secret seed
	bandersnatchPrefix := []byte("jam_val_key_bandersnatch")
	bandersnatchInput := append(bandersnatchPrefix, seed...)
	bandersnatchHash := hash.Blake2bHash(bandersnatchInput)
	bandersnatchSecret = bandersnatchHash[:]

	// Derive Bandersnatch public key from secret seed
	bandersnatchPublicKey, err := vrf.GetPublicKeyFromSecret(bandersnatchSecret)
	if err != nil {
		return nil, nil, types.Ed25519Public{}, types.BandersnatchPublic{},
			fmt.Errorf("failed to derive Bandersnatch public key: %w", err)
	}

	copy(bandersnatchPublic[:], bandersnatchPublicKey)

	return ed25519Secret, bandersnatchSecret, ed25519Public, bandersnatchPublic, nil
}

// TrivialSeed generates a 32-byte seed from a 32-bit unsigned integer.
// The seed is generated by repeating the 4-byte little-endian encoding of i eight times.
func TrivialSeed(i uint32) [32]byte {
	var seed [32]byte
	// Encode i as 32-bit little-endian
	binary.LittleEndian.PutUint32(seed[:4], i)
	// Repeat 8 times
	for j := 1; j < 8; j++ {
		copy(seed[j*4:(j+1)*4], seed[:4])
	}
	return seed
}
