package extrinsic

import (
	"bytes"
	"testing"

	"github.com/New-JAMneration/JAM-Protocol/internal/types"
)

func TestGuaranteeInit(t *testing.T) {
	controller := NewGuaranteeController()

	if controller.Len() != 0 {
		t.Fatalf("Expected 0 guarantees, got %d", controller.Len())
	}
}

func padSignature(signature types.Ed25519Signature, targetLength int) types.Ed25519Signature {
	// Convert fixed-size array to slice first
	sigSlice := signature[:]
	padding := bytes.Repeat([]byte{0}, targetLength-len(sigSlice))
	// Append to the slice
	paddedSlice := append(sigSlice, padding...)
	// Convert back to Ed25519Signature
	var result types.Ed25519Signature
	copy(result[:], paddedSlice)
	return result
}

func TestGuaranteeAdd(t *testing.T) {
	controller := NewGuaranteeController()

	// Create a test guarantee with complete data
	guarantee := types.ReportGuarantee{
		Report: types.WorkReport{
			PackageSpec: types.WorkPackageSpec{
				Hash:         types.WorkPackageHash{0x30, 0x46, 0x6e, 0x0a, 0xe1, 0xb0, 0x5d, 0xde, 0x52, 0x49, 0x87, 0x24, 0x75, 0xf6, 0xbe, 0xea, 0xc3, 0x68, 0xfd, 0x01, 0x4b, 0x5a, 0x34, 0x13, 0xce, 0xb3, 0x2d, 0x38, 0x72, 0x14, 0x32, 0x84},
				Length:       42,
				ErasureRoot:  types.ErasureRoot{0x7a, 0xf1, 0x1f, 0xda, 0xa7, 0x17, 0xc3, 0x98, 0xe2, 0x23, 0x21, 0x18, 0x42, 0xb4, 0x13, 0x92, 0xf1, 0x8d, 0xf4, 0xbb, 0xc4, 0xea, 0x0f, 0x4c, 0xfb, 0x97, 0x2f, 0x19, 0xc7, 0xa6, 0x49, 0x49},
				ExportsRoot:  types.ExportsRoot{0xe8, 0xe5, 0x29, 0x49, 0xf6, 0xe4, 0xfb, 0x1d, 0x94, 0x32, 0x48, 0xdf, 0x48, 0xc3, 0xf2, 0xb5, 0x38, 0x20, 0x0f, 0xdd, 0xfe, 0xa2, 0x23, 0x88, 0xe5, 0xe0, 0x61, 0xbe, 0x8e, 0xbf, 0x21, 0xa7},
				ExportsCount: 69,
			},
			Context: types.RefineContext{
				Anchor:           types.HeaderHash{0xc0, 0x56, 0x4c, 0x5e, 0x0d, 0xe0, 0x94, 0x25, 0x89, 0xdf, 0x43, 0x43, 0xad, 0x19, 0x56, 0xda, 0x66, 0x79, 0x72, 0x40, 0xe2, 0xa2, 0xf2, 0xd6, 0xf8, 0x11, 0x6b, 0x50, 0x47, 0x76, 0x89, 0x86},
				StateRoot:        types.StateRoot{0xf6, 0x96, 0x76, 0x58, 0xdf, 0x62, 0x6f, 0xa3, 0x9c, 0xbf, 0xb6, 0x01, 0x4b, 0x50, 0x19, 0x6d, 0x23, 0xbc, 0x2c, 0xfb, 0xfa, 0x71, 0xa7, 0x59, 0x1c, 0xa7, 0x71, 0x54, 0x72, 0xdd, 0x2b, 0x48},
				BeefyRoot:        types.BeefyRoot{0x93, 0x29, 0xde, 0x63, 0x5d, 0x4b, 0xbb, 0x8c, 0x47, 0xcd, 0xcc, 0xbb, 0xc1, 0x28, 0x5e, 0x48, 0xbf, 0x9d, 0xba, 0xd3, 0x65, 0xaf, 0x44, 0xb2, 0x05, 0x34, 0x3e, 0x99, 0xde, 0xa2, 0x98, 0xf3},
				LookupAnchor:     types.HeaderHash{0x60, 0x75, 0x1a, 0xb5, 0xb2, 0x51, 0x36, 0x1f, 0xbf, 0xd3, 0xad, 0x5b, 0x0e, 0x84, 0xf0, 0x51, 0xcc, 0xec, 0xe6, 0xb0, 0x08, 0x30, 0xae, 0xd3, 0x1a, 0x53, 0x54, 0xe0, 0x0b, 0x20, 0xb9, 0xed},
				LookupAnchorSlot: 33,
				Prerequisites:    []types.OpaqueHash{},
			},
			CoreIndex:      3,
			AuthorizerHash: types.OpaqueHash{0x02, 0x2e, 0x5e, 0x16, 0x5c, 0xc8, 0xbd, 0x58, 0x64, 0x04, 0x25, 0x7f, 0x5c, 0xd6, 0xf5, 0xa3, 0x11, 0x77, 0xb5, 0xc9, 0x51, 0xeb, 0x07, 0x6c, 0x7c, 0x10, 0x17, 0x4f, 0x90, 0x00, 0x6e, 0xef},
			AuthOutput:     []byte{0x01, 0x02, 0x03, 0x04, 0x05},
			Results: []types.WorkResult{
				{
					ServiceId:     16909060,
					CodeHash:      types.OpaqueHash{0x70, 0xa5, 0x08, 0x29, 0x85, 0x1e, 0x8f, 0x6a, 0x8c, 0x80, 0xf9, 0x28, 0x06, 0xae, 0x0e, 0x95, 0xeb, 0x7c, 0x06, 0xad, 0x06, 0x4e, 0x31, 0x1c, 0xc3, 0x91, 0x07, 0xb3, 0x21, 0x9e, 0x53, 0x2e},
					PayloadHash:   types.OpaqueHash{0xfa, 0x99, 0xb9, 0x7e, 0x72, 0xfc, 0xfa, 0xef, 0x61, 0x61, 0x08, 0xde, 0x98, 0x1a, 0x59, 0xdc, 0x33, 0x10, 0xe2, 0xa9, 0xf5, 0xe7, 0x3c, 0xd4, 0x4d, 0x70, 0x2e, 0xca, 0xac, 0xcd, 0x86, 0x96},
					AccumulateGas: 42,
					Result:        types.GetWorkExecResult(types.WorkExecResultOk, []byte{0xaa, 0xbb, 0xcc}),
				},
				{
					ServiceId:     84281096,
					CodeHash:      types.OpaqueHash{0xfc, 0xfc, 0x85, 0x7d, 0xab, 0x21, 0x6d, 0xaf, 0x41, 0xf4, 0x09, 0xc2, 0x01, 0x26, 0x85, 0x84, 0x6e, 0x4d, 0x34, 0xae, 0xdf, 0xea, 0xca, 0xf8, 0x4d, 0x9a, 0xdf, 0xeb, 0xda, 0x73, 0xfa, 0xe6},
					PayloadHash:   types.OpaqueHash{0xd5, 0x5e, 0x07, 0x43, 0x8a, 0xee, 0xeb, 0x0d, 0x65, 0x09, 0xab, 0x28, 0xaf, 0x8a, 0x75, 0x8d, 0x1f, 0xb7, 0x04, 0x24, 0xdb, 0x6b, 0x27, 0xc7, 0xe1, 0xef, 0x64, 0x73, 0xe7, 0x21, 0xc3, 0x28},
					AccumulateGas: 33,
					Result:        types.GetWorkExecResult(types.WorkExecResultPanic, nil),
				},
			},
		},
		Slot: 42,
		Signatures: []types.ValidatorSignature{
			{
				ValidatorIndex: 0,
				Signature:      padSignature(types.Ed25519Signature{0x5f, 0x6e, 0x74, 0xd2, 0x04, 0xc2, 0x49, 0x0e, 0x71, 0xbe, 0x44, 0x51, 0x96, 0x3d, 0x7d, 0x7d, 0xa7, 0x97, 0xd4, 0xfd, 0x37, 0xd6, 0xe0, 0xbd, 0xa5, 0x69, 0x27, 0xd0, 0x2a, 0x33, 0x02, 0xca, 0x3b, 0x3a, 0x0e, 0x08, 0xc9, 0x61, 0xe7, 0x58, 0x0e, 0x97, 0xa0, 0xf0, 0x8c, 0x26, 0x9f, 0x54, 0x97, 0x28, 0xf5, 0x2d, 0x9c, 0x7d, 0xe3, 0xaf, 0xfe, 0x85, 0x0a, 0x03, 0x71, 0x38, 0x00, 0x12}, 64),
			},
			{
				ValidatorIndex: 1,
				Signature:      padSignature(types.Ed25519Signature{0x3a, 0x68, 0x13, 0xf7, 0x69, 0x18, 0x95, 0xa4, 0x44, 0xd7, 0x2c, 0xad, 0x60, 0xe3, 0xd5, 0x4d, 0x64, 0x26, 0x6f, 0xba, 0xf5, 0x67, 0xd7, 0xa5, 0x81, 0x6a, 0x66, 0x23, 0xed, 0xcd, 0xba, 0xfe, 0xd3, 0x04, 0x51, 0x7e, 0x4d, 0xe8, 0x8a, 0x39, 0x9e, 0xd4, 0xd3, 0xfa, 0xa2, 0xfc, 0x86, 0xe3, 0x82, 0x43, 0xac, 0xbf, 0x48, 0x0a, 0x65, 0x2a, 0x23, 0x6c, 0x27, 0xe5, 0x15, 0x93, 0x90, 0x32}, 64),
			},
		},
	}

	controller.Add(guarantee)

	if controller.Len() != 1 {
		t.Fatalf("Expected 1 guarantee, got %d", controller.Len())
	}

	// Verify the added guarantee's core index
	if controller.Guarantees[0].Report.CoreIndex != 3 {
		t.Errorf("Expected core index 3, got %d", controller.Guarantees[0].Report.CoreIndex)
	}

	// Verify the slot
	if controller.Guarantees[0].Slot != 42 {
		t.Errorf("Expected slot 42, got %d", controller.Guarantees[0].Slot)
	}

	// Verify number of signatures
	if len(controller.Guarantees[0].Signatures) != 2 {
		t.Errorf("Expected 2 signatures, got %d", len(controller.Guarantees[0].Signatures))
	}

	// Verify number of work results
	if len(controller.Guarantees[0].Report.Results) != 2 {
		t.Errorf("Expected 2 work results, got %d", len(controller.Guarantees[0].Report.Results))
	}
}

func TestGuaranteeSet(t *testing.T) {
	controller := NewGuaranteeController()

	// Create test guarantees
	guarantee1 := types.ReportGuarantee{
		Report: types.WorkReport{
			PackageSpec: types.WorkPackageSpec{
				Hash:         types.WorkPackageHash{0x01},
				Length:       42,
				ErasureRoot:  types.ErasureRoot{0x02},
				ExportsRoot:  types.ExportsRoot{0x03},
				ExportsCount: 69,
			},
			Context: types.RefineContext{
				Anchor:           types.HeaderHash{0x04},
				StateRoot:        types.StateRoot{0x05},
				BeefyRoot:        types.BeefyRoot{0x06},
				LookupAnchor:     types.HeaderHash{0x07},
				LookupAnchorSlot: 1,
			},
			CoreIndex: 1,
		},
		Slot: 100,
		Signatures: []types.ValidatorSignature{
			{
				ValidatorIndex: 1,
				Signature:      padSignature(types.Ed25519Signature{0x08}, 64),
			},
		},
	}

	guarantee2 := types.ReportGuarantee{
		Report: types.WorkReport{
			PackageSpec: types.WorkPackageSpec{
				Hash:         types.WorkPackageHash{0x11},
				Length:       43,
				ErasureRoot:  types.ErasureRoot{0x12},
				ExportsRoot:  types.ExportsRoot{0x13},
				ExportsCount: 70,
			},
			Context: types.RefineContext{
				Anchor:           types.HeaderHash{0x14},
				StateRoot:        types.StateRoot{0x15},
				BeefyRoot:        types.BeefyRoot{0x16},
				LookupAnchor:     types.HeaderHash{0x17},
				LookupAnchorSlot: 2,
			},
			CoreIndex: 2,
		},
		Slot: 101,
		Signatures: []types.ValidatorSignature{
			{
				ValidatorIndex: 2,
				Signature:      types.Ed25519Signature{0x18},
			},
		},
	}

	guarantees := []types.ReportGuarantee{guarantee1, guarantee2}

	// Test setting guarantees
	controller.Set(guarantees)

	// Verify length
	if controller.Len() != 2 {
		t.Fatalf("Expected 2 guarantees, got %d", controller.Len())
	}

	// Verify content
	if controller.Guarantees[0].Report.CoreIndex != 1 {
		t.Errorf("Expected first guarantee core index 1, got %d", controller.Guarantees[0].Report.CoreIndex)
	}

	if controller.Guarantees[1].Report.CoreIndex != 2 {
		t.Errorf("Expected second guarantee core index 2, got %d", controller.Guarantees[1].Report.CoreIndex)
	}

	// Test setting empty slice
	controller.Set([]types.ReportGuarantee{})
	if controller.Len() != 0 {
		t.Fatalf("Expected 0 guarantees after setting empty slice, got %d", controller.Len())
	}
}

func TestGuaranteeSort(t *testing.T) {
	controller := NewGuaranteeController()

	// Add guarantees in unsorted order
	guarantees := []types.ReportGuarantee{
		{
			Report: types.WorkReport{
				PackageSpec: types.WorkPackageSpec{
					Hash:         types.WorkPackageHash{0x03},
					Length:       43,
					ErasureRoot:  types.ErasureRoot{0x03},
					ExportsRoot:  types.ExportsRoot{0x03},
					ExportsCount: 70,
				},
				Context: types.RefineContext{
					Anchor:           types.HeaderHash{0x03},
					StateRoot:        types.StateRoot{0x03},
					BeefyRoot:        types.BeefyRoot{0x03},
					LookupAnchor:     types.HeaderHash{0x03},
					LookupAnchorSlot: 3,
				},
				CoreIndex: 3,
			},
			Slot: 103,
			Signatures: []types.ValidatorSignature{
				{
					ValidatorIndex: 3,
					Signature:      types.Ed25519Signature{0x03},
				},
			},
		},
		{
			Report: types.WorkReport{
				PackageSpec: types.WorkPackageSpec{
					Hash:         types.WorkPackageHash{0x01},
					Length:       41,
					ErasureRoot:  types.ErasureRoot{0x01},
					ExportsRoot:  types.ExportsRoot{0x01},
					ExportsCount: 68,
				},
				Context: types.RefineContext{
					Anchor:           types.HeaderHash{0x01},
					StateRoot:        types.StateRoot{0x01},
					BeefyRoot:        types.BeefyRoot{0x01},
					LookupAnchor:     types.HeaderHash{0x01},
					LookupAnchorSlot: 1,
				},
				CoreIndex: 1,
			},
			Slot: 101,
			Signatures: []types.ValidatorSignature{
				{
					ValidatorIndex: 1,
					Signature:      types.Ed25519Signature{0x01},
				},
			},
		},
		{
			Report: types.WorkReport{
				PackageSpec: types.WorkPackageSpec{
					Hash:         types.WorkPackageHash{0x02},
					Length:       42,
					ErasureRoot:  types.ErasureRoot{0x02},
					ExportsRoot:  types.ExportsRoot{0x02},
					ExportsCount: 69,
				},
				Context: types.RefineContext{
					Anchor:           types.HeaderHash{0x02},
					StateRoot:        types.StateRoot{0x02},
					BeefyRoot:        types.BeefyRoot{0x02},
					LookupAnchor:     types.HeaderHash{0x02},
					LookupAnchorSlot: 2,
				},
				CoreIndex: 2,
			},
			Slot: 102,
			Signatures: []types.ValidatorSignature{
				{
					ValidatorIndex: 2,
					Signature:      types.Ed25519Signature{0x02},
				},
			},
		},
	}

	for _, g := range guarantees {
		controller.Add(g)
	}

	// Verify the order after sorting
	expectedCoreIndices := []types.CoreIndex{1, 2, 3}
	for i, expected := range expectedCoreIndices {
		if controller.Guarantees[i].Report.CoreIndex != expected {
			t.Errorf("Guarantee at index %d has CoreIndex %d, expected %d",
				i, controller.Guarantees[i].Report.CoreIndex, expected)
		}
	}
}
